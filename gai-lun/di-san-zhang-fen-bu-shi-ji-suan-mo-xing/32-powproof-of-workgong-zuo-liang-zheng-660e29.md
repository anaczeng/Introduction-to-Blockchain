#### 3.2.1 POW概念

POW是加密协议的一类。很多的加密协议是证明者使验证者确信她拥有秘密知识或特定的数学关系为真，例如我们用自己设定的密码登录账户。相比之下，**POW是证明者向验证者证明她在指定时间范围做了特定量的工作**，例如我们常说的比特币挖矿。POW的工作量一般用计算机处理时间来衡量。

POW的目的是使用经济手段来阻止滥用服务（Service Abuse）。用户在享受服务前必须付出一定量的劳动；POW就是服务申请方向服务提供方证明自己劳动的方法。为了达到这个目的，POW的关键点是它的不对称性：服务申请方的证明过程困难，服务提供方的验证过程容易。

> 滥用服务举例：
>
> 1. DoS攻击的例子。Google提供搜索引擎的服务，但服务的负载是有限的。某一恶意用户使用强大的爬虫机器人（robot）一秒钟产生上亿次检索，占用了Google大量资源以致其他用户无法使用Google服务。
>
> 2. 垃圾邮件（spam）。大量的垃圾邮件会占用邮箱容量。仅管现在邮箱容量很大，但是大量的无用信件会淹埋真正有用的信件，给用户使用带来不便。

下面举POW的一个简单例子：

用高斯消元法解线性方程组：

![](/assets/pow-1.png)

验证解的正确性，把结果代入式子：

![](/assets/pow-2.png)

亲自实践上面例子，就会发现“验证解是否正确的过程”明显比“解方程组得出解的过程”容易；求解过程对应上文的证明过程，验证过程不言而喻。这就是POW的精髓所在。当然，比特币挖矿要解的问题要比解线性方程组难得多，是Adam.Back在2002年提出的Hashcash；但其本质是一样的：求解过程难于验证过程。在下一节会详细介绍。

3.2.2 比特币区块链中的POW

通过上一节对POW概念及其用途的了解，聪明的读者也许猜到POW在区块链中的应用也是为了防止某种"服务滥用"。猜对了，就是我们开篇提及的女巫攻击\(sybil attack\)。

女巫攻击（sybil attack）

为了让读者对这个颇具魔幻色彩的概念先有个感性认识，我们又回到了熟悉的拜占庭将军场景。这次是在3.1.2存在叛徒的例子上做了修改：

5支军队参战，需要至少3支军队同时进攻才能获胜；其他条件不变。

参战将军已确定了子贡，子路和子有，而且子贡知道诚实的子路和子有是一定会发动进攻的\(具体解释请参考3.1节\)。为了不让战斗取得胜利，子贡必须控制剩下的两名将军并让他们按兵不动。于是子贡请女巫剪了两个纸人，让他们变成傀儡贡生和贡仆并成为将军。最后只有子路和子有两位将军发动进攻，战斗失败。

拜占庭将军

采取的决策

子路（诚实将军）

子有（诚实将军）

子贡（叛徒）

贡生（傀儡）

贡仆（傀儡）

表3-15：子贡操控傀儡贡生和贡仆，因此三支军队按兵不动；只有诚实的子路和子有发动攻击。这符合拜占庭将军问题原型中的一致性和正确性；但该例为原型变种，还要求诚实将军占总数多数才能获胜。

上面例子在拜占庭将军问题的原型上作了调整：它不仅要求诚实的将军执行一致正确的行动，还要求诚实将军占总数的多数。如果叛徒的实体\(Entity\)比诚实将军实体\(Entity\)多，问题无解——这也是比特币系统常说的51％攻击（详细介绍请参见5.X.X节）。然而，还存在这种情况：叛徒的实体\(Entity\)少，但由于伪造身份\(Identity\)极为容易，单个叛徒实体能制造多个身份进行投票以影响最终结果；就如上例中女巫Mallory用式神大法作乱。

女巫攻击是John.Douceur在2002年正式提出的，原文描述如下：

大规模点对点系统面临来自故障或恶意的远程计算元素的安全威胁。为了抵挡这种威胁，    这类系统都采取了冗余方案。但是，如果一个故障的实体能表现出多个身份，它就能大    比例地控制系统，并因此减少冗余的作用。

比特币的区块链就是一个大规模的点对点系统。在往后两章的介绍，你将会发现它及其冗余：每个节点都拥有全账本。尽管如此，它还是要解决在集体投票表决中，谁是大多数的问题。为了防止傀儡身份滥用投票权利，中本聪在比特币的白皮书中就给出了采用Hashcash的方案。

Hashcash

Hashcash是POW的具体实现之一，也是比特币区块链在挖矿过程中应用到的技术。对应之前POW的概念：矿工是证明者，全节点（包括矿工）是验证者；矿工需要向全节点证明在指定时间范围完成特定量的工作。

Hashcash的本质是用穷举输入的变量值来遍历哈希函数的输出空间以找到部分碰撞；并且除了穷举外，没有更快的方法（具体解释请参考2.1节）。部分碰撞是指散列值某部位连续位上的值相同。在Hashcash中是要求从左边开始固定位数取值皆为0；连续0的位数越多，需要遍历的散列值空间就越大，这也意味耗时越久（工作量越大）。

下面用四位的散列值输出举例：

0000

0001

0010

0011

0100

0101

0110

0111

1000

1001

1010

1011

1100

1101

1110

1111

Hashcash的证明部分是寻找部分碰撞散列值的过程；其验证部分就是将部分碰撞散列值对应的输入值用哈希函数再算一次。证明部分要经过大量的哈希计算，而验证部分只需一次。Hashcash在比特币区块链中具体的操作过程将会在第五章介绍。此外，仅管我们已经知道比特币区块链的POW具体指的是Hashcash，但为了不与习惯冲突，我们还是保持POW的说法。

Hashcash对付女巫攻击

Hashcash对付女巫攻击的本质是“一脑（CPU）一票”：一个节点的计算能力是无法复制的，而POW的机制既能证明又能验证计算能力。回到拜占庭将军的魔法世界，Hashcash问题就是傀儡试金石：子贡的脑容量一次也只能解答一个；而他的傀儡贡生和贡仆没有大脑，自然被识破而无法成为将军了。

