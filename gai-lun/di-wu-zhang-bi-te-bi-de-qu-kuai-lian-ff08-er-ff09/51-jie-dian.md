#### 5.1.1节点概述

节点运行Bitcoin Core程序，它们根据使用者的目的所执行的功能侧重点会有所不同，因此会选择运行程序的不同部分。Bitcoin Core程序的代码大致涵盖了三个方面的功能：钱包功能，即发起交易、查询交易、生成配对公私钥等；挖矿功能，也即是我们说的记账；验证并转发功能，验证交易和区块的合法性，并通过转发邻节点广播至全网。因此，节点根据其功能侧重点大致上分为全节点、挖矿节点和SPV节点。全节点和挖矿节点都拥有全账本，诚实的挖矿节点是在全节点的基础上再执行挖矿操作；它们也能执行钱包功能。SPV节点是后来产生的轻量级钱包节点，因为要满足用户移动端的需求。它们不存储全账本只下载区块头，所以依赖拥有全账本的对等节点提供所需的信息；此类节点不能执行挖矿和验证转发的功能。该节将依次对全节点，挖矿节点和SPV节点进行介绍。

表5-1：节点类型和描述![](/assets/fig-table-5-1.png)![](/assets/fig-5-1.png)

图5-1：不同节点可涵盖的功能。红圈是侧重的功能，蓝圈是可以执行的功能。

#### 5.1.2 全节点

全节点下载全账本，并对照比特币事先制定的规则验证区块和交易的合法性；合法的区块和交易将被转发。全节点是比特币骨干网的组成部分。此外，它也可以执行钱包功能。根据上述说法，挖矿节点也属于全节点；但平常说的全节点狭义指那些不执行挖矿功能，且主要执行验证转发功能的节点。

##### 5.1.2.1 全节点验证交易合法性

全节点根据事先制定好的比特币规则来验证交易的合法性。交易合法性验证主要包含以下几点：

（1）验证接收到交易的语法是否正确；

（2）验证接收到交易中的私钥签名是否与TXID所示的上一交易的地址公钥匹配；

（3） 验证接收到交易中的比特币是否是未花费的，技术上称为UTXO（unspent transaction outputs）；

（4）验证接收到交易中输入的比特币额度是否不小于输出中的额度；

（5）验证接收到交易是否不在主链区块中或在交易池内。交易池内存储尚未记录入区块但已接收到的合法交易。

##### 5.1.2.2 交易的公私钥脚本验证

验证交易合法性的重要一环是验证新交易的私钥签名和TXID所示的上一交易的地址公钥是否匹配。在比特币交易的输出中并没有直接显示公钥，而是其散列值；脚本和公钥哈希值相结合就成了输出中的脚本地址公钥（ScriptPublicKey）。事实上，私钥签名也是脚本，称为脚本签名（ScriptSig）。该验证过程就是将新交易的脚本签名和上一个交易的脚本地址公钥拼接在一起，看是否能不出错地成功运行。如果运行全部代码后不出现错误，则公私钥配对成功；否则该交易无效。该脚本语言是一种栈语言，常用命令及栈的介绍可回顾上一章的4.2.4.3节，本节重点阐述这些命令的执行过程。以下是全节点验证公私钥匹配的具体步骤：

![](/assets/step-1.png)

步骤（1）～（6）验证了公钥的正确性，是比特币发送者指定的；步骤（7）证明私钥是有效的。这六个步骤中只要有一步出现错误，交易就无效了。注意：加了“&lt;&gt;”符号的是数据，以“OP\_”开头的是命令。下面以交易“b18c…”和它上一个交易“3de4…”为例，省略非必要信息：

![](/assets/fig-5-2.png)

图5-2：交易“b18c…”验证公私钥匹配过程。红色字体标明了交易“b18c…”的输入来源于交易“3de4…”的输出。蓝色字体标明了在验证过程中所需要的数据。感兴趣的读者可以通过在线转换器验证②通过哈希计算得出和⑤一致的结果。

##### 5.1.2.3 全节点验证区块合法性

全节点根据事先制定好的比特币核心共识规则来验证区块的合法性。区块合法性验证主要包含以下几点：

（1）验证接收到区块的语法是否正确；

（2）验证Merkle树根是否正确；

（3）验证区块头的散列值是否不大于nBits；

（4）验证时间戳是否不早于前面十一个区块的中位数时间，且不晚于该区块链接的上一个区块未来两小时的时间；

（5）验证包含交易的有效性：输入输出非空，交易大小不超过规定的字节数，以及交易的币额在有效的货币单位（例如非负数）；

##### 5.1.2.4 全节点的钱包功能

比特币的钱包功能非常完备，可以生成配对公私钥、发起交易、查询交易等等。下面两个例子涵盖了常用的钱包功能。为了让读者明白在比特币系统中真正发生的过程，此处直接用Bitcoin Core程序中的命令来讲解。

###### 例子1：

子贡先从鲁国钱庄处获得了8BTC，然后他转移4BTC给卫国钱庄，剩下的3.99BTC找零转回给自己。

（1）子贡先使用getnewaddress命令获取地址，然后发给鲁国钱庄用于接收8BTC；

> 输入：bitcoin-cli getnewaddress
>
> 输出：14cYAhJRknBkXDtG2r3VEMS8b6UeozngrQ

（2）过一段时间后，鲁国钱庄告诉子贡已经转账了；子贡使用getreceivedbyaddress命令并设置该地址和6为参数来查看该地址经过6个区块确认的接收额度；

> 输入：bitcoin-cli getreceivedbyaddress 14cYAhJRknBkXDtG2r3VEMS8b6UeozngrQ 6
>
> 输出：8.00000000

（3）子贡使用listunspent命令查看自己的未花交易UTXO；

> 输入：bitcoin-cli listunspent
>
> 输出：\[
>
> {
>
> 	“tixd”: “48aa4e2a01668e5ebab8988c3fae709e5a720c7bd3014ad1cb23187678cd92bb”,
>
> 	“vout”:1,
>
> 	“address”: “14cYAhJRknBkXDtG2r3VEMS8b6UeozngrQ”,
>
> 	“amount”:8.00000000
>
> 	“confirmation”:6
>
> }
>
> \]

（4）子贡使用createrawtransaction命令创建与卫国钱庄的交易，他将与鲁国钱庄交易的外指，卫国钱庄的地址公钥和支付4BTC额度，自己的公钥地址和3.99BTC零钱额度作为参数输入；获得一个原始十六进制的加密交易字符串；

> 输入：bitcoin-cli createrawtransaction '\[{"txid":"48aa4e2a01668e5ebab8988c3fae709e5a720c7bd3014ad1cb23187678cd92bb","vout":1}\]' '{"1D7twkUwiZxYPQanhi5PXpRYmMznhC3B46":4.00000000, ”14cYAhJRknBkXDtG2r3VEMS8b6UeozngrQ”:3.99000000}'
>
> 输出：0100000001bb92cd78761823cbd14a01d37b0c725a9e70ae3f8c98b8ba5e8e66012a4eaa480100000000ffffffff01c0897b0d000000001976a91427a0f3fa9836fae94672b95f6abbcc03e43203ba88ac00000000

（5）子贡使用decoderawtransaction命令，以（4）获得的字符串作为参数输入，查看	交易；

> 输入：bitcoin-cli decoderawtransaction 0100000001bb92cd78761823cbd14a01d37b0c725a9e70ae3f8c98b8ba5e8e66012a4eaa480100000000ffffffff01c0897b0d000000001976a91427a0f3fa9836fae94672b95f6abbcc03e43203ba88ac00000000
>
> 输出：\(略\)

（6）子贡确认（5）中交易内容无误后，使用signrawtransaction命令进行签名，以（4）中获得的字符串作为参数输入，获得新一串十六进制的加密交易字符串；

> 输入：bitcoin-cli signrawtransaction 0100000001bb92cd78761823cbd14a01d37b0c725a9e70ae3f8c98b8ba5e8e66012a4eaa480100000000ffffffff01c0897b0d000000001976a91427a0f3fa9836fae94672b95f6abbcc03e43203ba88ac00000000
>
> 输出：0100000004d5f9ea32d69973218d64a72992afec398eff25004432bf32dc269c253d96038e010000006a47304402204…

（7）子贡可以再次使用decoderawtransaction命令来确认交易内容，之后她使用sendrawtransaction命令，以（6）中获得的字符串作为参数输入，将交易发布到比特币网络，获得该交易的散列值。

> 输入：bitcoin-cli sendrawtransaction 0100000004d5f9ea32d69973218d64a72992afec398eff25004432bf32dc269c253d96038e010000006a47304402204…
>
> 输出：fdc2d201e9b8cbd2b7ffa0104323914725609dae30937f62f559a459cdc97676

至此，子贡在交易中的操作完成。他或卫国钱庄，或者是任何人都可以使用getrawtransaction命令，以（7）中获得的散列值作为参数输入来获取加密的交易信息；再使用之前的decoderawtransaction命令获取解密后具体的交易信息。

> 输入：bitcoin-cli getrawtransaction fdc2d201e9b8cbd2b7ffa0104323914725609dae30937f62f559a459cdc97676
>
> 输出：0100000001e15a001dbcd129a5c3b79c6305636ef2be0ee314f0c629612d441815cd53f065000000006a4730440220028234f1f7edb646a77…

值得注意的是，上面的过程并没有出现私钥，是因为signrawtransaction封装了私钥的操作：该例中的公钥地址是钱包生成的，所以钱包中有其对应的私钥。私钥代表了比特币的所有权，所以需要保护好私钥。私钥可以从钱包中导出，无加密的钱包直接执行dumpprivkey命令即可。有加密的钱包可以先执行walletpassphrase命令，并以设定好的密码和解锁秒数作为参数值；随后再执行dumpprivkey命令。加密钱包则使用encryptwallet命令，以自己设置的密码作为参数。比特币的钱包功能非常强大，还有查询区块信息，更改本地设置等等的命令。更详细的内容可以通过系统中的help命令查阅，附录3中收集了命令的条目。

> 输入：bitcoin-cli dumpprivkey 14cYAhJRknBkXDtG2r3VEMS8b6UeozngrQ
>
> 输出：（略）
>
>
>
> 输入：bitcoin-cli encryptwallet 123456
>
> 输出：（系统提示）
>
>
>
> 输入：bitcoin-cli walletpassphrase 123456 60
>
> 输出：无

值得一提的另一点是交易中的手续费。细心的读者发现比特币在转移的过程中总值似乎越来越少。鲁国钱庄转了8TC给子贡，但在子贡和鲁国钱庄的交易中，输入总值为8BTC，输出的总值却变为4BTC+3.99BTC=7.99BTC。那么还有0.01BTC的比特币去哪里了呢？这部分输入与输出的差价作为手续费奖励给了记账的矿工，所以总量是不变的。关于手续费，有两个有趣的地方：

1.	比特币交易的手续费并不是强制的。但是含有手续费的交易比不含手续费的交易有更高的优先级，能更早的被矿工打包到区块里被确认；而且手续费越多，优先级越高。在早期交易少的情况下，手续费并不影响交易被确认；但在现在交易多的情况下，没有手续费的交易有较高的可能性需要等上很长时间才被确认。这是因为每个区块有1M的限容，所以能打包的交易数量有上限。1M限容限制了交易的速度，也导致了交易费用的飙升，这与中本聪低手续费的初衷就背道而驰了。

2.	由于交易是不可逆的，一旦忘记将差额打回到自己的公钥地址，那么这部分差额就会自动成为手续费。比特币历史上出现过天价手续费，例如交易4BTC比特币却付了15BTC比特币的手续费，估计就是哪位粗心的家伙忘记了。



