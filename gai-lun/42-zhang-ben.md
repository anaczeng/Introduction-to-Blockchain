#### 4.2.1 比特币账本概览

比特币的账本就是"区块链"，由"区块"和作为"链"的哈希指针组成。区块链是哈希指针和由其链接起来所有有序区块的集合。第一个区块称为创世块，之后大约每十分钟产生一个新的区块；相当于账本新添一页。由于后一个区块头中存有前一个区块的散列值，所以哈希指针能确定区块的前后顺序。当两个区块同时出现时，链条会出现发叉；区块链的主链机制能让链条很快地收敛，主链以外的区块成为孤儿块。每个区块的核心部分除区块头外，还有具体交易的集合。比特币的字符串就被包含在这些具体的交易中。![](/assets/fig-4-6.png)

_图4-6：比特币账本概览示意图。_

#### 4.2.2 区块

区块由五部分组成：幻数，区块头，交易数量，交易和区块大小；其中区块头和交易是两个最重要的结构，具体介绍请参见4.2.3和4.2.4节。业界常将区块链比作账本，那么每个区块都相当于账本中的一页；区块头中包含的哈希指针相当于订书针，将每个区块有序地链接在一起。

![](/assets/ffig-4-7.png)

##### 比特币小知识：创世块（Genesis Block）

创世块是区块链的第一个区块，在北京时间2009年1月4日2:15:5为中本聪所挖得。相比往后的区块，创世块极为特殊，表现在以下三方面：

1. 由于前面没有区块可指向，所以它的数据是由硬代码写入的。例如：上一个区块头的散列值就设置为0000000000000000000000000000000000000000000000000000000000000000，这个值是不可被追溯的。

2. 其币基中的50个比特币是无法使用的。区块数据和交易数据是分开存储的。当客户端程序运行发现数据库为空时（即没有下载区块链数据），就会自动生成创世块，但是不会在交易数据里生成对应的币基交易；所以在区块信息里虽然能看到币基交易的信息，但在正真交易时无法在交易数据里找到该交易作为输入，故这50个比特币无法被使用。业内猜测这是中本聪故意为之的。

3. 在币基交易中，币基脚本就是那条在坊间广为流传的《泰晤士报》标题的加密值。因为没有可引用的上一个交易，所以币基交易中相当于输入秘钥签名的部分被替换成币基脚本，它可以是任意值。这条信息证明了创世块的产生不可能早于伦敦时间的2009年1月3日（对应北京时间的2009年1月4日）。此外，业内认为这也反映了中本聪这位创始者的动机。![](/assets/ffig-4-8%281-2%29.png)

创世块的数据：

```
{
  "hash": "000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f", --区块 0的散列值
  "confirmations": 404228, --该区块被后面所有404228个区块确认
  "size": 285, --区块大小
  "height": 0, --区块高度
  "version": 1, --版本
  "merkleroot": "4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b", --Merkle树根
  "tx": [
    "4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b" --交易的TXID
  ],
  "time": 1231006505, --Unix时间戳
  "mediantime": 1231006505, --前十一个区块的时间中位数，区块0前面没有任何区块，故和自己时间相同
  "nonce": 2083236893, --随机数
  "bits": "1d00ffff", --nBits
  "difficulty": 1, --难度
  "chainwork": "0000000000000000000000000000000000000000000000000000000100010001",
  --得到该长度链条大约需要的穷举（哈希）次数
  "nextblockhash": "00000000839a8e6886ab5951d76f411475428afc90947ee320161bbf18eb6048" 
  --下一个区块的散列值；因为区块0前面没有区块，故没有显示前区块的信息； 
  --区块0前区块的散列值默认为0000000000000000000000000000000000000000000000000000000000000000
}
```

#### 4.2.3 区块头

区块头是区块链的核心结构之一。它包含了区块的基本信息，由六部分组成：版本，前区块头散列值，Merkle树根，时间，nBits和随机数。版本\(号\)，时间和nBits用于全节点验证区块有效性。前区块头散列值将当前区块和上一个区块以链表的形式链接起来，Merkle树根将当前区块的所有交易和区块头以Merkle树的形式链接了起来。nBits是验证是否成功挖矿的重要信息，随机数是挖矿操作的主要部分；Merkle树根也会受挖矿操作的影响。区块头是区块流链和交易树链的交汇处（区块链有3条链条，详细介绍请参见4.2.5节）。

![](/assets/fig-4-9.png)

_图 4-9：区块头结构示意图_

表4-2：区块头每部分大小和功能的具体介绍。

![](/assets/fig-table-4-2.png)

**难度值（Difficulty）**用于表示矿工找到一个比系统规定目标\(nBits\)值小的散列值的难度，它可用于调控区块产生间隔的时长。区块产生的平均间隔控制在10分钟左右：当区块产生的平均间隔大于10分钟，难度值会降低；当其小于10分钟时，难度值会提升。难度值每2016个区块，即大概两个星期会更新一次。

> 难度值计算公式：
>
> difficulty = difficulty\_1\_target / current\_target
>
> 下一个难度确定公式：
>
> next\_difficulty = \(previous\_difficulty \* 2016 \* 10 minutes\) / \(time to mine last 2016 blocks\)

目标值\(target\)是256位的二进制数值。传统上difficulty\_1\_target是这样的散列值：前32位皆为0，后面224位皆为1。current\_target是解包\(unpacked\)后的nBits，下面是nBits和current\_target进行变换的例子，为了方便表达使用了十六进制：

![](/assets/fig-4-10.png)

图4-10：nBits和current\_target的转化过程，以创世块中的1d00ffff为例。

创世块的区块头散列值与其nBits做对比：创世块区块头的散列值明显小于它nBits，所以该散列值有效。

![](/assets/fig-4-11.png)

图4-11：current\_target不为零的最高位比创世块的散列值大，因此该散列值符合比nBits小的要求。

##### 计算机小知识：Unix时间

Unix时间是从1970年1月1日\(UTC/GMT\)的午夜开始计算经过的秒数，不考虑闰秒。一小时的Unix时间是3600秒，一天的Unix时间是86400秒。过去Unix时间用32位存储，这会引发2038年问题：32位将在2038年1月19日3时14分7秒耗尽，系统将会发生问题。现在解决方案是使用64位。

#### 4.2.4 交易

##### 4.2.4.1 交易结构

交易是区块链的另一个核心结构，它包含了账本记录交易的具体信息，并且是区块链中交易树链和交易流链的交汇处（区块链有3条链条，详细介绍请参见4.2.5节）。交易由六部分信息组成：版本号，输入数量，输入列表，输出数量，输出列表和锁时间。

![](/assets/fig-4-12.png)

_图 4-12：交易结构示意图_

表4-3：交易每部分大小和功能的具体介绍。

![](/assets/fig-table-4-3.png)

**币基交易**是特殊的交易，表现在以下两方面：

1. 币基交易是发行新比特币的场所，所以它的输入部分不能查询到上一个交易。新产生的比特币作为挖矿激励机制的一部分奖励给成功记账的矿工。

2. 由于币基交易是产生新比特币的交易，所以输入部分没有外指（outpoint，详细介绍请参见4.2.4.2节）；币基脚本（相当于普通交易的私钥签名部分）可以写入任意的信息，例如中本聪就在这里留下了泰晤士报的一个标题（详细内容请参见4.2.2节）。当区块头的随机数被穷举完后，币基交易就成了矿工主要穷举随机数的场所。

##### 4.2.4.2 输入和输出

输入和输出是交易结构中的核心部分。一般普通交易可以有多个输入，但至多有两个输出。币基交易的输入和输出与普通交易的不同。

普通交易的输入：

表4-4：普通交易输入每部分大小和功能的具体介绍。

![](/assets/fig-table-4-4.png)表 4-5：外指每部分大小和功能的具体介绍。

![](/assets/fig-table-4-5.png)

表4-6：普通交易输出每部分大小和功能的具体介绍。

![](/assets/fig-table-4-6.png)表4-7：币基交易输入每部分大小和功能的具体介绍

![](/assets/fig-table-4-7.png)

币基交易的输出就和普通交易的输出一样，此处就不多做介绍。

币基交易数据：

普通交易数据：

比特币是一连串的数字签名，这是中本聪2008年在比特币白皮书中给出的定义。组成比特币的私钥签名和公钥地址的字符串被隐藏在散列值中，分别存储在输入的私钥签名脚本和输出的公钥地址脚本里。比特币也是区块链中交易流链的组成部分；交易流链的另一个组成部分是外指中的散列值TXID。

图4-13：交易流链在区块中的示意图。

图4-14：图4-13比特币示意图。这一串的数字签名就是比特币。在所有比特币被挖掘出来前，每个区块都会在币基交易中产生新的比特币。每个比特币都能追溯回到产生它的币基交易。

4.2.4.3 脚本

细心的读者一定注意到上一章中的公钥地址中出现了一些奇怪的字符，例如“OP\_DUP”。这是比特币脚本（Bitcoin Script），一种基于栈的语言。比特币系统中99.99%的脚本都用于验证交易。常见以下7个命令：

脚本命令

描述

OP\_DUP

复制栈上最顶端的数据并打进栈头

OP\_HASH160

需使用栈头数据，计算该数据的散列值，并将该值打进栈头

OP\_EQUALVERIFY

依次运行OP\_EQUAL和OP\_VERIFY

OP\_CHECKSIG

需使用一个私钥签名和公钥地址。当交易数据能用生成公钥的同个ECDSA私钥生成签名，则打真值入栈头，否则打入假值

OP\_EQUAL

需使用栈最上面两个数据；将这两个数据做比较，如果相同则打真值入栈头，否则打假值入栈头

OP\_VERIFY

需使用栈头；如果该数据为0则脚本将以失败运行终止

OP\_RETURN

当执行该命令脚本将以失败运行终止

表4-8：脚本作用的具体介绍。

计算机小知识：栈\(Stack\)

栈是程序中常用的数据结构，它的逻辑结构和线性表相同，只是在运算上有所限制：先进的元素后出。因此，它也叫先进后出的线性表。进行插入和删除操作的一端叫栈顶\(top\)，另一端叫栈底\(bottom\)。假如有4，2，3，1四个元素，将它们推入\(push\)和弹出\(pop\)栈的例子如下：

图4-15：存储4、2、3、1做压入操作。最先存储的4在栈低，最后存储的1在栈顶。

图4-16：删除4的弹出操作。先进去的元素只能最后出来：4最早推入栈，要删除它只能将前面的元素都弹出栈后才能弹出4。

4.2.5 脑洞：三类链条

比特币账本有两大特性：不可篡改性和可追溯性。作为支撑这两大性质物质基础的三类链条功不可没。虽然在前面章节有所介绍，但要将它们汇总在一起时，才能窥见设计者的匠心独运。为了易于区分，本书为三大链条取了名字，分别是区块流链，交易树链和交易流链。

区块流链：用哈希指针将区块头有序链接起来的集合。这条链子和上一章介绍的Linking方法非常类似。前区块头散列值就类似于Linking方法中的消息函数，一层层嵌套前面的消息。拥有全账本的节点就类似于TSS机构，可以确定区块发生的时间顺序且不可篡改。区块流链在账本中只有一条。

图4-17：区块流链和Linking数据结构做对比。

交易树链：区块中用哈希指针将该区块所有交易与区块头中Merkle树根链接起来的集合。这条链子直接采用了Bayer和Haber的方案。交易树链在账本的每一页中都有一条。

图4-18：交易树链和Merkle Tree Style数据结构做对比。

现在将区块流链和交易树链结合起来，这就与上一章介绍的TIMESEC系统的数据结构非常相似了。

区块头中有时间，区块中的每笔交易也有自己的时间。比特币的交易内容就是TIMESEC模型中的消息。

图4-19：只表示出区块块链和交易树链的账本结构和TIMESEC系统的数据结构非常类似。

交易流链：用公私钥和TXID联系起来的比特币交易集合。公私钥验证保证了交易顺序的正确性和有效性；TXID和公私钥让所有交易都可追溯回其币基交易，让账本具有了可追溯的性质。这也是区块链开始和TIMESEC区分的地方。交易流链在账本中有很多条，毎新产生一个币基交易就新生一条交易流链。链条与链条间会交错分叉，是三类链条最复杂的一条。交易流链的图示可参见4.2.4.2节的比特币部分。

三大链条并非彼此孤立互不干扰，而是一脉相承层层相扣。区块中任何一个交易的变动必然会引起该区块头的变动，因为Merkle树根受到了影响；Merkle树根的变动必定导致该区块头散列值的变动，随机数可能需要重新穷举以得到一个新的符合nBits要求的散列值；而该区块头散列值的变更必然引起后面所有区块头的改变。真所谓牵一发而动全身，设计为之精妙之绝。请看这个例子，假如我们将图4-20交易2中伯牛的公钥地址改成了子贡的公钥地址，三大链条马上发生了连锁反应：

（1）    交易4验证失败，伯牛的私钥不可能验证子贡的公钥地址，交易流链断开；

（2）    交易2的变动通过交易树链传递到了头部的Merkle树根，区块2头部的散列值需要重新穷举随机数计算；

（3）    区块2头部的散列值变更通过区块流链传递到之后所有的区块头部，这些区块的头部散列值都需要重新穷举随机数计算。

图4-20：三条链子汇总。黑色代表区块流链部分，白色代表交易树链部分，蓝色代表交易流链部分。

图4-21：当交易2的信息被篡改后引发的一系列变动。

实际上区块流链和交易树链中对哈希指针的使用，让信息的篡改基本成了工作量浩大且几乎不可能完成的事情。还记得2.4.2节中哈希指针和普通指针的对比吗？之前所有区块头的信息摘要其实都隐含在后面的区块头中，只是相隔越远，所含的信息摘要比例越小。所以在后面5.X.X介绍的51%攻击中，攻击者并不是在原来的区块上篡改信息，而是构造新的区块链条在系统中取代诚实链条的主链地位；区块链出现了分叉，但失去主链地位的链条依然会保存在区块链中。从这一点上看，区块链即使被攻击了，它曾被写入的信息依然是不可被篡改的。

4.2.6 主链，孤儿块（orphan block）和分叉（fork）

图4-22：主链示意图。蓝色部分的是主链，红色部分是失效的区块。

主链是包涵计算量最多的链条，可近似认为是最长的链子。它是账本中的有效信息；不在主链上的消息都是无效的。如上图，创世块－&gt;区块1－&gt;区块2－&gt;区块3－&gt;区块4－&gt;区块5－&gt;区块6－&gt;区块7－&gt;区块8－&gt;区块9...是主链；包含在这些区块里的交易才是有效的。一般默认交易首次被包含在主链区块后，该区块又链接上6个或更多的主链区块，这个交易就被确认了。例如交易1首次被包含在主链的区块3中，当主链区块9被挖出后，交易1也就被确认了。

孤儿块是指非主链上的区块。虽然账本里依然存在这些区块的记录，但是包含在里面的交易是无效的；包括孤儿块的币基交易，新产生的比特币永久失效。孤儿块产生的同时，链条就出现了分叉。只要多于一个区块的哈希指针指向同一个区块，那么链条就出现了分叉。分叉的原因有很多，除了上述的原因外，还有版本升级等。

比特币小知识：软分叉和硬分叉

比特币系统作为新生的事物，它是粗糙不完美的，比如1M限容带来的低处理量。比特币社区的人们就希望对不完美的系统进行改造。一旦开始实行改造后的新代码，有些节点采用了就是新节点，有些节点未采纳就成了旧节点。

“硬分叉，是当比特币协议规则发生改变，旧节点拒绝接受由新节点创造的区块的情况。违反规则的区块将被忽视，矿工会按照他们的规则集，在他们最后见证的区块之后创建区块。

软分叉，是当比特币协议规则发生改变，旧的节点并不会意识到规则是不同的，它们将遵循改变后的规则集，继续接受由新节点创造的区块。矿工们可能会在他们完全没有理解，或者验证过的区块上进行工作。”

比特币的软硬分叉之争暴露新生比特币有许多问题亟待解决，也反应了人们对这新生事物的诸多异见。有兴趣的读者可以深入了解这方面的信息。Mike Hearn博客是一个不错的去处。虽然这位程序员已经离开了比特币社区，并且人们对他观点褒贬不一，但这并不妨碍他之前的文章成为了解比特币历史以及技术的一个好资源。任何事物在新生期都会引发争论，这都需要读者在接触不同观点时保持自己独立的思考。

