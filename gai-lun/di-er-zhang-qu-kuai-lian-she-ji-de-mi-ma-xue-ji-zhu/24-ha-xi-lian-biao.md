#### 2.4.1 线性表

线性表是种常见的数据组织方式。一组数据一般除了第一个和最后一个外，其他都是头尾相接的。数据用节点存储，节点间通过指针链接以形成链表。前面节点的指针指向后面节点。

![](/assets/fig-2-9.png)

_图 2-9：线性表一般的链式存储。该图中有3个节点：p、q和r；，和分别是节点中的数据。节点通过指针链接在一起。_

普通链表使用指针，哈希链表就是将指针换成了哈希指针，链接方式也稍微发生了变化：普通链表的指针是向后指向，但哈希链表是向前指向。对普通链表来说，头并不特殊；但对哈希链表来说，头非常特殊，因为它没有指向的前驱，因此它的哈希值是硬代码。

![](/assets/fig-2-10.png)

_图 2-10：线性表的哈希链表存储。该图中有3个节点：p、q和r；，和是节点中的数据。H\(p\)是p的散列值，H\(q\)是q的散列值。哈希链表的头节点和其他节点不同，因为它没有指向的节点，因而它的散列值为Null。_

现在我们也看到了普通链表和哈希链表在结构上的区别，这是2.3.2节中指针和哈希指针区别的延伸。下一节将会看到这些区别将给数据的CRUD带来极大的不同。

#### 2.4.2 CRUD：链表VS哈希链表

区块链本质上是一个电子系统，电子系统总离不开基本CRUD操作。CRUD分别是英文create，read，update和delete。它对应了四种基本的数据操作：写，读，更新和删除。具体到链表操作就是数据的插入，查询和删除；其中更新操作可以分解成删除和插入。下面就这3方面将普通链表和哈希链表进行对比。

##### 插入：

普通链表：

新节点在链表头部插入：

（1）将新节点的指针指向原来的头节点。

![](/assets/fig-2-11.png)

_图 2-11：新节点p插入头结点q之前，只需将节点p的指针赋予指向节点q存储地址的值即可。_

新节点在链表中部插入：

（1）将新节点的指针指向要插入位置的后一个节点；

（2）将要插入位置前一个节点的指针改为指向新节点。

![](/assets/fig-2-12.png)

_图 2-12：新节点p插入节点q和r的中间。先将节点p的指针指向节点r的存储地址，再将节点q指针改为指向节点p的存储地址。_

新节点在链表尾部插入：

（1）    将最后一个节点的指针指向新节点。

![](/assets/fig-2-13.png)

图 2-13：新节点p插入节点r的后面，只需将节点r的指针赋予指向节点p存储地址的值即可。

哈希链表：

新节点在哈希链表尾部插入：

（1）将新节点的指针指向最后一个节点；

（2）计算最后一个节点的哈希值，并将其存储在新节点。

![](/assets/fig-2-14.png)

_图 2-14：新节点p插入节点r的后面。首先将节点p的指针指向节点r的存储地址，然后计算出节点r的散列值存储在节点p中。_

新节点在哈希链表中部或头部插入：

细心的读者一定发现，新节点要是插入在链条的中间或者头部都是件很麻烦的事情。插入在中间，除了要执行（1）（2）外，还要对插入位置后面的所有节点都进行改造。插入位置后的第一节点不仅要将其指针改为指向新节点，并且还要计算新节点的散列值。这个节点发生了变化，这意味它存储在下一节点的散列值也发生了变化，从而引发了多米诺骨牌效应。如果新节点在头部插入，那么后面的节点都要重新计算自己存储的哈希值，也可以理解为重新构造一个新链表了。

![](/assets/fig-2-15.png)

_图 2-15：左一是插入前的哈希链表；右一是将节点p插入节点r和s的中间；右二是将节点p插入节点q之前。红色标识因插入操作而需重新计算的散列值。很明显，插入节点后面的散列值都需要重新计算。_

> 小结：普通链表的插入操作非常简单，变动至多只会涉及到插入位置的前一个节点和后一个节点；也即是发生变动的旧节点不超过两个。哈希链表的插入操作会随着插入位置的向前，工作量呈线性增长；如果新节点的插入位置在哈希链表的头部，那么整条链表的散列值都需要重新计算。

##### 删除：

普通链表：

在链表头部删除节点：

（1）释放删除节点的存储空间。

![](/assets/fig-2-16.png)

_图 2-16：删除头结点p。还需要释放节点p的存储空间即可。_

在链表中部删除节点：

（1）将要删除节点前驱节点的指针改为指向删除节点的后继节点；

（2）释放删除节点的空间。

![](/assets/fig-2-17.png)

_图 2-17：删除链表中部节点。将节点的指针指向节点的存储地址，释放节点的存储空间。_

在链表尾部删除节点：

（1）将要删除节点前驱节点的指针域改为Null；

（2）释放删除节点的空间。

![](/assets/fig-2-18.png)

_图 2-18：删除链表尾部节点r。只需将节点q的指针域重新赋值为Null，释放节点r的存储空间。_

哈希链表：

聪明的读者一定发现，哈希链表顶多是删除最后一个的节点，将其空间释放。如果要删除头部或者中部的节点，那么之后的节点都要重新调整；这就和在头部和中部插入节点遇到的问题相同。

在哈希链表尾部删除节点：

（1）释放删除节点的存储空间。

![](/assets/fig-2-19.png)

_图 2-19：删除哈希链表尾部节点r，只需要释放节点r的存储空间即可。_

在哈希链表中部或头部删除节点：

![](/assets/fig-2-20.png)

_图 2-20：图一是删除节点前的哈希链表；图二是要删除中间节点q；图三是要删除头部节点p。红色标识因删除操作而需重新计算的散列值。很明显，删除节点后面的散列值都需要重新计算。_

> 小结：普通链表不管在哪个位置删除节点都非常容易，只需要一步（即使不释放删除节点的存储空间，链表中也没有节点指向它了）。相比之下，哈希链表除了在链尾删除节点简单外，在其他位置删除节点都会产生和插入节点一样的问题。删除位置之后节点的散列值都需要重新计算。如果在哈希链表头部删除节点，那么整个链表都需要重新构造了。

##### 查询：

因为查询操作不需要对链表进行修改，所以普通链表和哈希链表在这方面不存在本质区别。它们都是通过指针从一个元素跳到下一个元素；通过元素值和查询关键字的对比找到需要的信息。

#### 2.4.3 脑洞：俄罗斯套娃&&信息基因遗传

通过2.4.2节对普通链表和哈希链表在CRUD上的比较。我们发现哈希链表因含有指向值的散列值的缘故，数据操作起来有诸多限制；特别是数据在链表中的位置越靠前需要操作的工作量就越多。如果要写入，更新或删除的数据恰好在初始位置，那么整条链表都作废了。这也意味着无论链表多长，初始数据都会影响最新写入的数据。不仅初始数据如此，链条上所有数据都会影响其后面产生的所有数据。

上面这段话看起来有些拗口，我们换个形象点的比喻。每个新产生的数据都是一个俄罗斯套娃，前面数据的摘要（散列值在这里用“消息摘要”这个名称会更加贴切）都是更小一点的娃娃被套在里面。越前面的消息摘要是越小的娃娃被套在越里面。

![](/assets/fig-2-21.png)

_图 2-21：新写入节点s就像一套俄罗斯套娃。前面节点p，q和r的消息摘要被一层一层地套在里面；象征头结点p的娃娃被包含在最里面。无论哪一层的娃娃发生了变化，它都不是原来的那套俄罗斯套娃了。_

或者将哈希链表构造的过程想象成基因遗传的过程。数据的消息摘要就和人类基因一样，通过哈希指针一代一代传到最新数据中。如果你否认，也即添加、修改或删除了前面的某些数据，那么在其后产生的数据就完全不一样了。

我们脑洞可以再大一些。哈希链表的每个节点都记录着一个事件，那么事件的先后顺序就在结构上被确定下来了，而且是不可更改的。这跟现实世界的时间线很像。除去人为赋予时钟时间的概念，时间线无非就是一系列事件的有序排列。哈希链表虽然在已有的数据上做改动很困难，但是从某一个节点处旁生出新的链条来却是一件没有技术障碍的事情。下面是个有意思的例子：

> 节点p的数据记录了“子贡外祖母成亲”的事件，节点q的数据记录了“子贡外祖母诞下子贡母亲”的事件，节点r的数据记录了“子贡出生”的事件，节点s的数据记录了“子贡训仆”的事件。仆人在受训后心生怨气，穿越回过去并“杀害了怀孕前的外祖母”，产生了新的节点q’；节点q’及其后面的节点r’、s’等形成了新的时间线。
>
> ![](/assets/fig-2-22.png)_图 2-22：哈希链表VS时间线。节点q的数据包含“子贡外祖母成亲”的信息”的信息；节点q’的数据包含“子贡外祖母在怀孕子贡母亲前就去世了”的信息。假设子贡的回到过去，将怀孕前的外祖母杀害了，相当于在节点p后面链接上了节点q’。时间线在节点p处分叉，产生了一个新的平行宇宙。_



