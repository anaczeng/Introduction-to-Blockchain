我们的老朋友子贡又遇到了新的问题：

> 子贡有上千本账本。当仆人清扫完书房后，他如何确认这些账本都没有被翻动过呢？

用封条，子贡想；可是检查上千份封条是否破损也是件令人头疼的事情。有捷径吗？有，那就是把这上千部打封条的账本捆起来再在封条上打个大封条。只需要检查大封条的完整性，就可以判断账本是否被翻动过。

在虚拟世界中，Merkle树这种数据组织方式就可以把所有文件通过哈希指针链接起来，它根部的散列值就相当于上文提及的大封条。Merkle树是Ralph Merkle在1979年获得专利的数据结构，其直观图如下。除了叶节点外，每个节点都存储着指向节点的散列值，也即是图中的箭头都是2.3节介绍的哈希指针。



图2-23：Merkle树。叶子节点的文件1，文件2等是原文件。散列值11是文件1经过哈希计算后的散列值输出，同理可得散列值12,21,和22.散列值1是散列值11和散列值12作为消息输入得出的散列值输出；同理可得散列值2.最后的Merkle树根是散列值1和2作为消息输入的散列值输出。

由于哈希指针的大量存在，Merkle树防篡改的能力非常强大。只要叶子节点中的文件出现了一丝改动，该文件的哈希值就会发生变动反映在它的后继节点上；最终，这个改动会通过哈希指针层层传递到根节点。



图2-24：a.叶子节点的文件1被篡改成了文件1（1），它的散列值11也发生了变化；b.散列值11的变化导致了散列值1的变化；c.文件1被篡改的影响最终传递到Merkle树的根节点。红色部分表示篡改后发生变化的地方。从左边红色箭头可看出篡改的影响是自底向上的。

也即是说，只需要对比一下过去时刻和现在时刻的Merkle树根，即可知道它所涵盖的文件是否遭到篡改。除此之外，通过Merkle树还能快速定位出被修改的文件。具体过程只需要将新的Merkle树和旧的做对比。现在让我们回到子贡的场景：

子贡离开书房前，按照Merkle树结构给账本打上了哈希封条，并将产生的散列值依次记		下。

其中大封条也即是Merkle树根值为

76 ED 87 27 98 A0 B3 CB 3F 48 81 94 EF 09 0F 4E 21 02 4A EF。

当他回来时，对比Merkle树根值，如果依然是：

76 ED 87 27 98 A0 B3 CB 3F 48 81 94 EF 09 0F 4E 21 02 4A EF，

子贡可以放心地相信在他离开期间，账本没被翻动。

假如在子贡离开期间，仆人翻动了账本1。Merkle树根值变成了

68 9E F0 7F 79 39 4F 65 1E 8A B4 94 AB 23 63 28 3B CD 69 E0。

发现Merkle树根值不对的子贡现在需要找出这个被篡改的文件：

（1）对比根的两个前驱节点，发现散列值1不一致；

（2）对比散列值1的两个前驱节点，发现散列值11不一致。至此，可判定账本1被篡改。



图2-25：定位被篡改的文件。右边是Merkle树，黄色部分代表被子贡对比过散列值的节点；左边的散列值对应着右边树上黄色的节点，红色标记出与原来散列值不同的新散列值。可以从左边的箭头可看出，对篡改文件的定位是自顶向下的。

2.6 数字签名

关注区块链的读者经常会听到公钥地址，私钥签名的术语；并知道用私钥签名可以向大众认证自己在所配对公钥地址中比特币的所有权。大多数读者可能知其然不知其所以然。这些术语和数字签名技术息息相关。在介绍数字签名前，先了解公钥密码还是必须的，因为数字签名是反用公钥密码并和哈希函数结合的技术。也许这也解释了它为什么如此强大，可以一种技术防止三种威胁。

2.6.1公钥密码

公钥密码的初衷是为了保证信息的机密性，以防止窃听。想想这个场景：

	子贡遣仆到钱庄送帐，他又不想账目被仆人半路翻阅，怎么办呢？

封条？不行！只能发现，不能阻止账本被翻阅。那就只能上锁了。于是钱庄给子贡送来一把锁，子贡把账本上锁后遣仆送至了钱庄。而本身持有钥匙的钱庄自然能解锁翻阅账本，而没有钥匙的仆人则不可能了。

公钥密码中的公钥就好比钱庄送出的锁，私钥就是钱庄自己收好的钥匙。为了更好地说明公钥密码的使用过程，下面图示直接用公私钥来说明：

λ	钱庄生成了一对公私钥；

λ	钱庄将公钥发给了子贡，将私钥自己妥善保管；

λ	子贡收到公钥后，对账本进行了加密；

λ	子贡将账本密文发给了钱庄；

λ	钱庄收到账本密文，用自己的私钥解密后获得账本的明文。



图2-26：子贡和钱庄使用公钥密码来防止仆人窃听的过程。左边方框内是钱庄执行的步骤；右边方框内是子贡执行的步骤；中间方框是仆人可以窃听到的信息。

从上图可清楚看到，子贡和钱庄在通讯中只交换了公钥和账本密文，这也是仆人可获得的信息。尽管如此，仆人依然不能知道账本得内容。这是因为公钥不能解密被自己加密后的密文，只有与其配对的私钥能解密。这意味着公钥和私钥是不一样的，因此公钥密码也称为非对称密码。

2.6.2 数字签名：反过来使用的公钥密码

公钥密码似乎和认证，不可抵赖的性质没关系，但仔细想想并非如此。只有拥有私钥的人才能解密被对应公钥加密的密文；也只有拥有私钥的人才能加密被对应公钥解密的明文。这个排他性，就使私钥拥有了和指纹、个人身份证一样的效果。既然如此，我们反过来使用就可以向任何拥有公钥的人证明自己是信息的发送人。数字签名就是用数学的方法来证明电子消息和文件的可信赖性。



公钥

私钥

作用

持有者

可以是任何人

个人



公钥密码

发送方用于加密

接收方用于解密

保护机密性

数字签名

验证方用于解密

签名方用于加密

认证和保证不可抵赖性

表格2-1：公钥密码和数字签名的比较。

我们从上面表格清楚的看到数字签名和公钥密码的公钥和私钥的操作刚好是相反的，所以数字签名是公钥密码的反用就很好理解了。不过你还有这样的疑问，到现在为止都没有用上哈希函数呀。这是因为公钥密码运行慢，一般在实际操作中，都会将消息先进行哈希计算，再用私钥签名。为了更好说明数字签名的操作过程和作用，子贡，仆人，鲁国和卫国的钱庄都出场了：

卫国钱庄收到一条署名为子贡的消息。





但卫国钱庄并不信任这条消息，因为它有可能：

（1）仆人伪造的（不能认证）；

（2）即使发送者确实是子贡，事后他依然可否认这条消息。例如抵赖成仆人伪造的（可以抵赖）。

假如子贡的意图确实如消息所述，他如何向卫国钱庄保证不发生以上两种情况呢？聪明的子贡想到了数字签名。他做了以下的操作：

（1）用哈希函数求出了消息的散列值；

（2）算出公私钥密码对，并用私钥对消息的散列值加密得出签名（密文）；

（3）将公钥，消息和签名发给卫国钱庄

卫国钱庄在收到消息和密文后，做出了如下操作：

（4）用子贡的公钥得到了消息的散列值；

（5）用相同的哈希函数求出消息的散列值；

（6）两个散列值做比较，如果相同，则认证成功；否则失败。



图2-27：数字签名流程图

假如子贡和卫国钱庄发生了纠纷，要向第三方仲裁方鲁国钱庄证明消息是子贡发的。鲁国钱庄也只需要重复卫国钱庄的操作就可以判定消息的确是子贡发送的，子贡无法抵赖。

在比特币系统中，拥有私钥的人能被认证持有对应公钥地址的比特币，以及不可以抵赖交易和上面例子在本质上是一样的，详细的介绍在第四章。此外，现在普遍使用的公钥密码算法是RSA，不过比特币区块链中使用的算法是椭圆曲线密码（ECC）。篇幅所致，这里就不对算法展开讨论；而且对区块链来说，具体哪种算法并不重要，因为它们最后达到的目的是一样的。

2.6.3 对数字签名的疑问

1. 数字签名能保证消息机密性吗？

数字签名并不保证消息的机密性。首先，它的目的在于认证和不可抵赖；如果需要既签名又加密，可以查询PGP技术。其次，从它的操作过程可以看出，签名者用私钥签名加密；公钥持有者可以是任何有需要的人，他们都可以解密。最后，在数字签名的例子里，子贡是以明文的形式发送消息给卫国钱庄的，所以数字签名并不保证消息的机密性。

2. 能否盗取别人的签名伪装成他人发送消息？

不可以。这和纸质的签名是不一样的，数字签名的私钥，消息和签名是一一对应的关系。当公钥解密签名后，出来的消息如果和发送的消息对不上时，验证就失败了。

当然，如果盗取的是私钥，那么就可以伪装成他人发送消息了。这也就是为什么比特币强调私钥的保护。如果你的私钥泄漏了，那么私钥对应地址的这些比特币就有可能被他人盗取了。









